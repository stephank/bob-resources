import _ from 'lodash';
import ms from 'ms';
import Vue from 'vue';
import pathToRegexp from 'path-to-regexp';
import { mapGetters } from 'vuex'

import Poller from './poller';

// Methods for which we create actions.
const HTTP_METHODS = ['GET', 'POST', 'PUT', 'PATCH', 'DELETE'];
// Methods that return a response containing new data.
const HTTP_UPDATE_METHODS = ['GET', 'PUT', 'PATCH'];

// Create a Vuex store module.
export const createResourcesModule = () => {
    // Fetch state by path.
    const state = {};
    // Pollers by path.
    const pollers = {};

    // Get fetch state for a path, setting initial state if needed.
    const getState = (path) => {
        if (!_.has(state, path)) {
            Vue.set(state, path, {
                // Whether a request is in flight.
                progress: false,
                // The last error.
                error: null,
                // The most recent data.
                data: undefined
            });
        }
        return state[path];
    };

    // Get the poller for a path, creating it if needed.
    const getPoller = (commit, path) => {
        let poller = _.has(pollers, path) && pollers[path];
        if (!poller) {
            poller = pollers[path] = new Poller(path);
            // Connect events to store mutations.
            poller.on('fetch', (opts) => {
                commit('resourceRequested', { path, opts });
            });
            poller.on('result', (data, opts) => {
                commit('resourceFetched', { path, data, opts });
            });
            poller.on('error', (error, opts) => {
                commit('resourceError', { path, error, opts });
            });
        }
        return poller;
    }

    const getters = {
        // Getter for all resource state.
        // Specific access is accomplished with `mapResources`.
        resources: (state) => state
    };

    const mutations = {
        // Request was sent.
        resourceRequested(state, { path }) {
            const obj = getState(path);
            obj.progress = true;
            obj.error = null;
        },
        // Response received.
        resourceFetched(state, { path, data, opts }) {
            const method = (opts && opts.method) || 'GET';
            const obj = getState(path);
            obj.progress = false;
            if (_.includes(HTTP_UPDATE_METHODS, method)) {
                obj.data = data;
            }
        },
        // Bad response.
        resourceError(state, { path, error }) {
            const obj = getState(path);
            obj.progress = false;
            obj.error = error;
        }
    };

    const actions = {
        // One-shot fetch a path. If a request is in-flight, returns the
        // promise. Otherwise, starts a request immediately.
        getResource({ commit }, { path }) {
            const poller = getPoller(commit, path);
            return poller.once();
        },
        // Start polling a path. Polling is reference counted; each call
        // must be matched with a call to `unpollResource`.
        pollResource({ commit }, { path, interval }) {
            const poller = getPoller(commit, path);
            poller.start(interval);
        },
        // Stop polling a path. Polling is only actually stopped once all
        // references are released.
        unpollResource({ commit }, { path, interval }) {
            const poller = getPoller(commit, path);
            poller.stop(interval);
        }
    };
    // Create actions for other HTTP methods.
    _.without(HTTP_METHODS, 'GET').forEach((method) => {
        const action = `${method.toLowerCase()}Resource`;
        actions[action] = ({ commit }, { path, data }) => {
            const poller = getPoller(commit, path);
            const opts = { method };
            if (data !== undefined) {
                opts.body = JSON.stringify(data);
            }
            return poller.once(opts);
        };
    });

    // Build the module.
    return { state, getters, mutations, actions };
};

// Routing step that performs a resource lookup.
//
// Takes a property name to set on `routeParams`, and a route-like path to the
// resource, of which parameters are filled with the current `routeParams`.
//
// Alternatively, the path can be generated by a custom function that takes the
// current `routeParams` as its sole argument.
export const resolveResource = (outParam, pathFn) => {
    if (typeof pathFn === 'string') {
        pathFn = pathToRegexp.compile(pathFn);
    }
    return [
        ({ dispatch }, params) => {
            return dispatch('getResource', { path: pathFn(params) })
                .then((result) => {
                    params[outParam] = result;
                });
        }
    ];
};

// Map one or more resources as a computed properties. Requires the view to
// include the mixin.
//
// The values of the map are parameter objects with the properties:
//
//  - `path`: A route-like path to the resource, of which parameters are filled
//    with component prop values. Alternatively, a function that takes the
//    component instance as its sole argument and should return the path.
//
//  - `fetch`: Optional. Causes the resource to be fetched when the component
//    is created.
//
//  - `poll`: Optional. When specified, will start polling the instance at the
//    given interval in milliseconds during the component lifespan. May also be a
//    string interval, such as `'20s'`.
//
//    A combination of `fetch` and `poll` causes an immediate fetch, as well as
//    continuous polling. Without `fetch`, polling may initially display a
//    cached value until the next interval.
//
// A value may also be a string if only `path` is to be specified.
//
// The poller interval is tracked in the store. When multiple pollers are
// active, the smallest interval is used.
//
// Other, non-polling fetches, like `mapResources` with `fetch`,
// `resolveResource` in a route, or a direct call to the `getResource` action,
// all reset the interval timer.
//
// A common scenario is to combine `resolveResource` to fetch during routing
// (and thus also validate route parameters), then use `mapResources` to bring
// the data into the component (optionally with `poll`).
export const mapResources = (map) => {
    const props = {
        ...mapGetters(['resources'])
    };
    _.each(map, (opts, name) => {
        if (typeof opts === 'string') {
            opts = { path: opts };
        }

        let pathFn = opts.path;
        if (typeof pathFn === 'string') {
            pathFn = pathToRegexp.compile(pathFn);
        }

        const fn = props[name] = function() {
            const { resources } = this;
            const path = pathFn(this);
            if (_.has(resources, path)) {
                return resources[path].data;
            }
        };

        let poll = opts.poll;
        if (typeof poll === 'string') {
            poll = ms(poll);
        }

        Object.assign(fn, {
            resourcePathFn: pathFn,
            resourceWantFetch: Boolean(opts.fetch),
            resourceWantPoll: isFinite(poll),
            resourcePollInterval: Number(poll)
        });
    });
    return props;
};

// Mixin for views to access resources.
export const resourcesMixin = {
    methods: {},
    // On create, apply `fetch` and `poll` options specified in computed
    // properties from `mapResources`.
    created() {
        const store = this.$store;
        this.$polledResources = _(this.$options.computed)
            .filter('resourcePathFn')
            .map((fn) => ({ fn, path: fn.resourcePathFn(this) }))
            .filter(({ fn, path }) => {
                if (fn.resourceWantFetch) {
                    store.dispatch('getResource', { path });
                }
                if (fn.resourceWantPoll) {
                    store.dispatch('pollResource', {
                        path,
                        interval: fn.resourcePollIntervall
                    });
                }
                return fn.resourceWantPoll;
            })
            .value();
    },
    // On destroy, remove pollers from `mapResources`.
    destroyed() {
        const store = this.$store;
        this.$polledResources.forEach((payload) => {
            store.dispatch('unpollResource', payload);
        });
    }
};
// Create component methods for each HTTP method. These can be called with a
// resource path, or (more often) with a computed property name from which to
// take the path.
HTTP_METHODS.forEach((method) => {
    const action = `${method.toLowerCase()}Resource`;
    resourcesMixin.methods[action] = function(path, data) {
        if (path[0] !== '/') {
            path = this.$options.computed[path].resourcePathFn(this);
        }
        return this.$store.dispatch(action, { path, data });
    };
});


// Default instance.
export const resourcesModule = createResourcesModule();

// Convenience default export.
export default {
    createModule: createResourcesModule,
    resolve: resolveResource,
    map: mapResources,
    mixin: resourcesMixin,
    module: resourcesModule
};
